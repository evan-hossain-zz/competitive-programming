#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <assert.h>

#define in freopen("input.txt", "r", stdin);
#define out freopen("output.txt", "w", stdout);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define mp(a, b) make_pair(a, b)
#define infinity (1 << 28)
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define CF ios_base::sync_with_stdio(0);cin.tie(0);
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define SZ(v) (int)(v.size())
#define eps 10e-7

//int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
//int col[4] = {1, 0, -1, 0};
//int row[4] = {0, 1, 0, -1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;
//
//template <class T> T sqr(T a){return a * a;}    // square
//template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
//template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
//template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
//template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str();}    // convert a number to string
//template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
//template <class T> void show(T a){cout << a << endl;}
//template <class T> void show(T a, T b){cout << a << ' ' << b << endl;}
//LL bigmod(LL B,LL P,LL M){LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define MAX 200010
/***********************************THE GRASS IS ALWAYS GREENER ON THE OTHER SIDE***********************************/

class CtuRobots {
public:
	double maxDist(int B, vector <int> cost, vector <int> cap) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, bool hasAnswer, double p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	CtuRobots *obj;
	double answer;
	obj = new CtuRobots();
	clock_t startTime = clock();
	answer = obj->maxDist(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	double p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 100;
	p1 = {50,25};
	p2 = {1,1};
	p3 = 0.6666666666666666;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 25;
	p1 = {23,5,8,20,15};
	p2 = {108,30,42,100,94};
	p3 = 55.0;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 1382;
	p1 = {0,0,0,1000,1000,0,1000,0};
	p2 = {2039,4819,5923,1577,8749,9182,3652,4918};
	p3 = 6503.238683127572;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 209;
	p1 = {185,130,109,1,45,117,127,13,2,37,6,1,2};
	p2 = {93,5,278,4,20,54,93,213,103,5,225,32,5};
	p3 = 190.48376771833563;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 9956;
	p1 = {3229,736,1325,2680,410,1227,1378,499,1525,1722,1262,2080,2581,1505,1019,480,3155,836,2697,616,136,2032,2345,3154,1953,1654,344,3079,1426,199,2857,1714,2952,996,1567,2674,2054,2110,949,2412,2148,1016,234,1932,1554,1943,1625,1266,258,2924,49,1693,3140,309,557,12,2760,227,2497,330,646,1935,3032,2671,2433,164,1472,3080,717,221,2483,1309,1174,12,917,2335,3086,148,64,189,2628,1660,2983,109,1920,2470};
	p2 = {934850,214,15807606,2426,176520,1900009,1184867,40550,1774843,2953,77834310,7276,3139890,695,213862217,13,193864,189,557664,1206555,85133,381662,4887,115027,2186890,218075,1,2024,9,95244962,7,906,3485642,52962078,58645759,785706,303,18,189,819600,17528041,11616471,92719012,82351,12752,634,26122233,215485,58,5506810,101874,130429471,2,1,68966,76303,321766922,463,26,225,207,52,1739,246841,496,228,4749453,191,79,10560,1414194,7529,13,521935,1,2,11590618,4020,105,3,28,3,2855,189909573,1,295052};
	p3 = 2.1034261053998655E8;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = 8852;
	p1 = {2547,912,2592,1085,296,523,2257,2347,1822,261,334,2159,528,2739,201,964,427,2038,26,2361,234,2063,2885,2178,2708,730,2902,326,306,2794,1725,13,137,2169,388,1124,1464,2120,2357,1544,2794,2260,185,650,2852,124,1767,453,1331,1397,1991,1166,413,1428,2862,1194,1139,571,1299,1232,267,2027,746,1971,2695,2586,185,1319,1088,2818,2604,1798,475,1252,1767,2277,545,601,2160,325,2749,1161,1172,1075,1925,2468,1596,1116,1558,2226,1302,796,775,1105,418,334,2872,1921,2830,2448,2914,2634,1386,2516,492,1029,1134,2934,2017,1741,1675,2593,2233,2401,68,683,2053,155,183,923,2276,1823,65,2290,2448,92,2468,819,837,303,1440,705,291,2348,2562,765,1926,14,2514,2403,2671,1143,1358,121,376,2874,2447,1769,1686,967,967,2492,2472,2014,1686,2291,1093,1801,818};
	p2 = {263268,256181,476791,365614,265352,19307,243180,84909,98175,367524,241474,479623,277638,111229,155356,415525,234382,97870,451466,58375,268277,404582,484789,458230,529286,449840,103208,199505,319373,294746,78005,326456,14418,257144,135669,238651,411723,99122,20421,298154,278407,153564,24778,73065,110408,392693,510192,362399,333830,125893,130946,345134,261418,230632,306751,451242,175675,459988,150787,349338,134594,255227,263645,180770,436965,502871,242085,318340,220576,189202,395789,390659,101649,337117,440471,466547,513054,316694,30382,38826,472506,67698,223953,397305,325564,57949,194651,443500,443188,431386,220061,400640,286085,189461,324214,171813,420711,260549,426526,208052,83343,429483,366076,52443,224742,333286,544259,335276,93282,326772,82841,225256,270357,547610,397526,193336,182374,439866,255860,111363,509167,228847,218257,39438,212242,378338,88972,127544,59230,428847,155553,116333,255176,396356,223463,226360,38283,6238,173455,447707,332111,60485,398523,462205,55397,148417,529738,460063,177715,404809,336155,50750,24165,530386,394811,512481,230296,45797,370008};
	p3 = 408339.73124862404;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Cat Ctu is going to buy some robots.
// His budget is B dollars.
// You are given vector <int>s cost and cap that describe a store.
// For each valid i, the store sells one robot that costs cost[i] dollars and has a fuel tank that can hold at most cap[i] units of fuel.
// Initially, all robots have a full fuel tank.
// Ctu can purchase any subset of these robots, as long as he does not exceed his budget.
// 
// 
// Once Ctu purchases some robots, he will number them sequentially, starting from 1.
// Note that he may number them in any order - he is not required to preserve the order in which the robots' parameters are given in cost and cap.
// 
// 
// The robots are going to travel along a straight line.
// They will all start at the position 0 on the line.
// Ctu wants to send a robot as far as possible in the positive direction.
// Precise rules of robot movement are given below.
// 
// 
// The robots' movement is continuous. They are able to travel arbitrary positive real distances.
// Moving 1 unit of distance consumes 1 unit of fuel.
// The robots will initially all travel together in the positive direction. One by one, in the order given by their numbers, the robots will then turn back. Multiple robots with consecutive numbers may turn back at the same position.
// Each robot must return back to position 0.
// As a robot turns back, it can donate any amount of fuel to the next robot. (I.e., for each valid k, robot k may donate some of its fuel to robot k+1. Note that after the donation robot k must still have enough fuel to get back to position 0.)
// The amount of fuel a robot carries can never exceed the initial capacity of its fuel tank.
// 
// 
// Given that Ctu buys the optimal subset of robots he can afford, and given that he then numbers and programs them optimally, compute and return the largest position that can be reached by one of Ctu's robots.
// 
// DEFINITION
// Class:CtuRobots
// Method:maxDist
// Parameters:int, vector <int>, vector <int>
// Returns:double
// Method signature:double maxDist(int B, vector <int> cost, vector <int> cap)
// 
// 
// NOTES
// -Your return value must have an absolute or relative error smaller than or equal to 1e-6
// 
// 
// CONSTRAINTS
// -B will be between 1 and 10,000, inclusive.
// -cost will have between 1 and 500 elements, inclusive.
// -cap will have exactly the same number of elements as cost.
// -Each element of cost will be between 0 and B, inclusive.
// -Each element of cap will be between 0 and 1,000,000,000, inclusive. 
// 
// 
// EXAMPLES
// 
// 0)
// 100
// {50,25}
// {1,1}
// 
// Returns: 0.6666666666666666
// 
// In this case, Ctu has a budget of 100 dollars.
// He can buy both robots for 50+25 = 75 dollars.
// One of the robots will get the number 1 and the other will get the number 2.
// If they cooperate, one of these robots can reach the position 2/3 = 0.666666667.
// Here's how an optimal program looks like:
// Both robots travel together to the position 1/3.
// At this moment, each of them has 2/3 of a unit of fuel in its fuel tank.
// Robot 1 donates 1/3 of a unit of fuel to robot 2 and turns back.
// Robot 2 now has a full fuel tank again.
// It continues to the position 2/3.
// There it turns back and returns to position 0.
// 
// 1)
// 25
// {23,5,8,20,15}
// {108,30,42,100,94}
// 
// Returns: 55.0
// 
// 
// 
// 2)
// 1382
// {0,0,0,1000,1000,0,1000,0}
// {2039,4819,5923,1577,8749,9182,3652,4918}
// 
// Returns: 6503.238683127572
// 
// 
// 
// 3)
// 209
// {185,130,109,1,45,117,127,13,2,37,6,1,2}
// {93,5,278,4,20,54,93,213,103,5,225,32,5}
// 
// Returns: 190.48376771833563
// 
// 
// 
// 4)
// 9956
// {3229,736,1325,2680,410,1227,1378,499,1525,1722,1262,2080,2581,1505,1019,
// 480,3155,836,2697,616,136,2032,2345,3154,1953,1654,344,3079,1426,199,2857,
// 1714,2952,996,1567,2674,2054,2110,949,2412,2148,1016,234,1932,1554,1943,
// 1625,1266,258,2924,49,1693,3140,309,557,12,2760,227,2497,330,646,1935,3032,
// 2671,2433,164,1472,3080,717,221,2483,1309,1174,12,917,2335,3086,148,64,189,
// 2628,1660,2983,109,1920,2470}
// {934850,214,15807606,2426,176520,1900009,1184867,40550,1774843,2953,77834310,
// 7276,3139890,695,213862217,13,193864,189,557664,1206555,85133,381662,4887,
// 115027,2186890,218075,1,2024,9,95244962,7,906,3485642,52962078,58645759,785706,
// 303,18,189,819600,17528041,11616471,92719012,82351,12752,634,26122233,215485,
// 58,5506810,101874,130429471,2,1,68966,76303,321766922,463,26,225,207,52,1739,
// 246841,496,228,4749453,191,79,10560,1414194,7529,13,521935,1,2,11590618,4020,
// 105,3,28,3,2855,189909573,1,295052}
// 
// Returns: 2.1034261053998655E8
// 
// 
// 
// 5)
// 8852
// {2547,912,2592,1085,296,523,2257,2347,1822,261,334,2159,528,2739,201,964,427,
// 2038,26,2361,234,2063,2885,2178,2708,730,2902,326,306,2794,1725,13,137,2169,
// 388,1124,1464,2120,2357,1544,2794,2260,185,650,2852,124,1767,453,1331,1397,
// 1991,1166,413,1428,2862,1194,1139,571,1299,1232,267,2027,746,1971,2695,2586,
// 185,1319,1088,2818,2604,1798,475,1252,1767,2277,545,601,2160,325,2749,1161,
// 1172,1075,1925,2468,1596,1116,1558,2226,1302,796,775,1105,418,334,2872,1921,
// 2830,2448,2914,2634,1386,2516,492,1029,1134,2934,2017,1741,1675,2593,2233,
// 2401,68,683,2053,155,183,923,2276,1823,65,2290,2448,92,2468,819,837,303,1440,
// 705,291,2348,2562,765,1926,14,2514,2403,2671,1143,1358,121,376,2874,2447,1769,
// 1686,967,967,2492,2472,2014,1686,2291,1093,1801,818}
// {263268,256181,476791,365614,265352,19307,243180,84909,98175,367524,241474,479623,
// 277638,111229,155356,415525,234382,97870,451466,58375,268277,404582,484789,458230,
// 529286,449840,103208,199505,319373,294746,78005,326456,14418,257144,135669,238651,
// 411723,99122,20421,298154,278407,153564,24778,73065,110408,392693,510192,362399,
// 333830,125893,130946,345134,261418,230632,306751,451242,175675,459988,150787,349338,
// 134594,255227,263645,180770,436965,502871,242085,318340,220576,189202,395789,390659,
// 101649,337117,440471,466547,513054,316694,30382,38826,472506,67698,223953,397305,
// 325564,57949,194651,443500,443188,431386,220061,400640,286085,189461,324214,171813,
// 420711,260549,426526,208052,83343,429483,366076,52443,224742,333286,544259,335276,
// 93282,326772,82841,225256,270357,547610,397526,193336,182374,439866,255860,111363,
// 509167,228847,218257,39438,212242,378338,88972,127544,59230,428847,155553,116333,
// 255176,396356,223463,226360,38283,6238,173455,447707,332111,60485,398523,462205,
// 55397,148417,529738,460063,177715,404809,336155,50750,24165,530386,394811,512481,
// 230296,45797,370008}
// 
// Returns: 408339.73124862404
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
