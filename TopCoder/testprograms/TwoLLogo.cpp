#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

#define out freopen("output.txt", "w", stdout);
#define in freopen("input.txt", "r", stdin);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define infinity (1 << 28)
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define CF ios_base::sync_with_stdio(0);cin.tie(0);
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define SZ(v) (int)(v.size())
#define eps 10e-7

//int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
//int col[4] = {1, 0, -1, 0};
//int row[4] = {0, 1, 0, -1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;

template <class T> T sqr(T a){return a * a;}    // square
template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str();}    // convert a number to string
template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
template <class T> void print_all(T v) {for(int i = 0; i < v.size(); i++) cout << v[i] << ' ';};
template <class T> void print_all(T &v, int len) {for(int i = 0; i < len; i++) cout << v[i] << ' ';}     // prints all elements in a vector or array
template <class T> void print_pair(T v, int len) {for(int i = 0; i < len; i++) cout << v[i].first << ' ' << v[i].second << endl;} // prints pair vector
//LL bigmod(LL B,LL P,LL M){LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define MAX 500010
/*************************************************HABIJABI ENDS HERE******************************************************/


class TwoLLogo {
public:
    map<pair<int, int>, LL> mpp;
    int n, primary[31];
    LL gen(int indx, int col, int parmask, int curmask, int boshaisi)
    {
        cout << indx << ' ' << col << " " << parmask << ' ' << curmask << endl;
        if(col >= n - 1 || boshaisi == 2)
            return call(indx + 1, curmask);
        if(parmask & (1 << col))
            return gen(indx, col + 1, parmask, curmask, boshaisi);
        LL ret = gen(indx, col + 1, parmask, curmask, boshaisi);
        for(int i = 2; i <= n; i++)
        {
            int j, tem = curmask;
            for(j = 0; j < i; j++)
            {
                if(!(curmask & (1 << (col + j))))
                    tem |= (1 << (col + j));
                else
                    break;
            }
            if(j == i)
                ret += gen(indx, col + i, parmask | (1 << col), tem, boshaisi + 1) + 1;
        }
        return ret;
    }
    LL call(int indx, int mask)
    {
        if(indx == n)
            return 0;
        LL &ret = mpp[make_pair(indx, mask)];
        if(ret) return ret;
        return ret = gen(indx, 0, mask, primary[indx], 0);
    }
	long long countWays(vector <string> grid) {
        mpp.clear();
        int i, j;
        n = SZ(grid);
        for(i = 0; i < n; i++)
        {
            primary[i] = 0;
            for(j = 0; j < n; j++)
            {
                if(grid[i][j] != '.')
                    primary[i] |= (1 << j);
            }
        }
        return call(1, primary[0]);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, long long p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	TwoLLogo *obj;
	long long answer;
	obj = new TwoLLogo();
	clock_t startTime = clock();
	answer = obj->countWays(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	vector <string> p0;
	long long p1;

	// ----- test 0 -----
	disabled = false;
	p0 = {"....","...."};
	p1 = 1ll;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = {".##..","...#.",".#.#.","#...#"};
	p1 = 3ll;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = true;
	p0 = {"..#.","#.#.","....","..#."};
	p1 = 4ll;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = true;
	p0 = {"..",".."};
	p1 = 0ll;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 4 -----
	disabled = true;
	p0 = {".#.#","....",".#.#","...."};
	p1 = 34ll;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 5 -----
	disabled = true;
	p0 = {"##############","##############","#.############","#.############","#.############","#.############","#.############","#.############","#.#####.######","#.#####.######","#.#####.######","#....##.######","#######.######","#######.######","#######.######","#######.######","#######.######","#######.######","#######......#","##############"};
	p1 = 1350ll;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 6 -----
	disabled = true;
	p0 = {"#......",".#....#",".#.#...","#....#.",".##..#.",".#.....",".....#.",".#.#...",".#...#.","..##..."};
	p1 = 2386ll;
	all_right = (disabled || KawigiEdit_RunTest(6, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 7 -----
	disabled = true;
	p0 = {"...#..........................","..............................","..............................","..................#...#.......","..................#...........","..............................","...........#..................","..............................",".....#..#.....................",".......................#......","..................#.....#.....","..............................","..............................","..............................","..............................","..#...........................","..............................","..............................","..............................","#............................#","..............................",".....#.........#............#.","..............................",".........................#....",".#............................",".............#................","..............................","..............................",".......................#......",".............#................"};
	p1 = 5020791386ll;
	all_right = (disabled || KawigiEdit_RunTest(7, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Please note that this problem has a non-standard time limit: 3 seconds.
//
// A yet unknown "LL Company" wants to design a logo. After a long discussion, company designers decided that the logo should consist of two letters L drawn in some way.
//
// To start with something, designers drew N rows of M points each, one under another, so that these points form a rectangular grid. They also painted each point either white or black. Here is an example of what they could get for N = 4 and M = 5:
//
//
//
// Designers agreed to draw each letter L as a union of a horizontal and a vertical line segment intersecting at their left and bottom ends, respectively. The segments must have positive lengths, and their endpoints must be white grid points. All grid points that lie on the segments must be white as well. For example, here are two valid placements of a letter:
//
//  
//
//
// Note that neither the letters nor the grid can be rotated.
//
// The final requirement is that the two letters should be disjoint. That is, no white point should lie on two segments belonging to different letters.
//
// You are given the grid with N rows and M columns, encoded as a vector <string> grid with N elements, each containing M characters. Each character is either '.' or '#', meaning that the corresponding point is either white or black, respectively.
//
// Return the number of different possible logos with two L's drawn on them according to the requirements. Two logos are considered different if there is a pair of points that is connected by a line segment in exactly one of the logos.
//
//
// DEFINITION
// Class:TwoLLogo
// Method:countWays
// Parameters:vector <string>
// Returns:long long
// Method signature:long long countWays(vector <string> grid)
//
//
// CONSTRAINTS
// -grid will contain between 2 and 30 elements, inclusive.
// -All elements of grid will contain the same number of characters.
// -Each element of grid will contain between 2 and 30 characters, inclusive.
// -Each character of grid will be either '.' or '#'.
//
//
// EXAMPLES
//
// 0)
// {"....",
//  "...."}
//
// Returns: 1
//
//
//
//
//
// 1)
// {".##..",
//  "...#.",
//  ".#.#.",
//  "#...#"}
//
// Returns: 3
//
// This is the example from the problem statement. The three possible logos look as follows:
//
//  
//  
//
//
//
// 2)
// {"..#.",
//  "#.#.",
//  "....",
//  "..#."}
//
// Returns: 4
//
//
//  
//  
//  
//
//
//
// 3)
// {"..",
//  ".."}
//
// Returns: 0
//
// Too small for a logo.
//
// 4)
// {".#.#",
//  "....",
//  ".#.#",
//  "...."}
//
// Returns: 34
//
//
//
// 5)
// {"##############",
//  "##############",
//  "#.############",
//  "#.############",
//  "#.############",
//  "#.############",
//  "#.############",
//  "#.############",
//  "#.#####.######",
//  "#.#####.######",
//  "#.#####.######",
//  "#....##.######",
//  "#######.######",
//  "#######.######",
//  "#######.######",
//  "#######.######",
//  "#######.######",
//  "#######.######",
//  "#######......#",
//  "##############"}
//
// Returns: 1350
//
// Corners of L's are identified uniquely in this case, but line segment lengths can vary.
//
// 6)
// {"#......",
//  ".#....#",
//  ".#.#...",
//  "#....#.",
//  ".##..#.",
//  ".#.....",
//  ".....#.",
//  ".#.#...",
//  ".#...#.",
//  "..##..."}
//
// Returns: 2386
//
//
//
// 7)
// {"...#..........................",
//  "..............................",
//  "..............................",
//  "..................#...#.......",
//  "..................#...........",
//  "..............................",
//  "...........#..................",
//  "..............................",
//  ".....#..#.....................",
//  ".......................#......",
//  "..................#.....#.....",
//  "..............................",
//  "..............................",
//  "..............................",
//  "..............................",
//  "..#...........................",
//  "..............................",
//  "..............................",
//  "..............................",
//  "#............................#",
//  "..............................",
//  ".....#.........#............#.",
//  "..............................",
//  ".........................#....",
//  ".#............................",
//  ".............#................",
//  "..............................",
//  "..............................",
//  ".......................#......",
//  ".............#................"}
//
// Returns: 5020791386
//
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
